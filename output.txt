
"bookings.json"
---START-OF-FILE---
[
  {
    "amount": "2448",
    "name": "Souvenir Valencia",
    "category": "Sonstige Ausgaben",
    "type": "give",
    "date": "2025-05-31"
  },
  {
    "amount": "333",
    "name": "T-Mobile Hotspot",
    "category": "Internet & Telefon",
    "type": "give",
    "date": "2025-05-31"
  }
]
---END-OF-FILE---


"bot.py"
---START-OF-FILE---
# bot.py

import logging
from datetime import datetime
import os
import time
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from appium.webdriver.common.appiumby import AppiumBy
from selenium.common.exceptions import StaleElementReferenceException
from config import SCREENSHOT_DIR

logger = logging.getLogger(__name__)

class FinanzguruBot:
    def __init__(self, driver):
        self.driver = driver
        self.wait = WebDriverWait(driver, 15)

    def click_booking_button(self):
        self._safe_action(
            "Clicking booking button",
            lambda: self._click_element(
                AppiumBy.ANDROID_UIAUTOMATOR,
                'new UiSelector().description("Buchung hinzufÃ¼gen").instance(1)',
            ),
        )

    def enter_amount(self, amount: str):
        self._safe_action(
            "Entering amount",
            lambda: self._send_keys(AppiumBy.ACCESSIBILITY_ID, "Betrag", amount),
        )

    def switch_to_positive(self):
        self._safe_action(
            "Switching to positive transaction",
            lambda: self._click_element(AppiumBy.ACCESSIBILITY_ID, "Auf Positiv wechseln"),
        )

    def enter_name(self, name: str):
        self._safe_action(
            "Entering name",
            lambda: self._send_keys(AppiumBy.ACCESSIBILITY_ID, "Name", name),
        )

    def select_category(self, category: str):
        def action():
            self._click_element(
                AppiumBy.XPATH,
                '//android.widget.Button[@content-desc="Kategorie"]/com.horcrux.svg.SvgView',
            )
            self._send_keys(
                AppiumBy.ANDROID_UIAUTOMATOR,
                'new UiSelector().text("Kategorie suchenâ€¦")',
                category,
            )
            self._click_element(
                AppiumBy.ANDROID_UIAUTOMATOR,
                'new UiSelector().className("com.horcrux.svg.PathView").instance(2)',
            )

        self._safe_action(f"Selecting category '{category}'", action)
        
    def select_date(self, date: str):
        target_date = datetime.strptime(date, "%Y-%m-%d")
        today = datetime.today()

        # Calculate month difference
        diff_months = (today.year - target_date.year) * 12 + (today.month - target_date.month)
        logger.debug(f"Months difference: {diff_months}")

        def click_day_with_instance_fallback(day_text: str):
            # Try instance(1)
            selector_instance_1 = f'new UiSelector().text("{day_text}").instance(1)'
            elements = self.driver.find_elements(AppiumBy.ANDROID_UIAUTOMATOR, selector_instance_1)
            if elements:
                try:
                    logger.debug(f"Instance(1) found for day {day_text}, clicking it")
                    elements[0].click()
                    return
                except StaleElementReferenceException:
                    logger.debug("Stale element on instance(1), retrying find and click")
                    elements = self.driver.find_elements(AppiumBy.ANDROID_UIAUTOMATOR, selector_instance_1)
                    if elements:
                        elements[0].click()
                        return
                    else:
                        logger.debug("No elements found after retry for instance(1)")

            # If instance(1) fails or no elements, try instance(0)
            selector_instance_0 = f'new UiSelector().text("{day_text}").instance(0)'
            elements = self.driver.find_elements(AppiumBy.ANDROID_UIAUTOMATOR, selector_instance_0)
            if elements:
                try:
                    logger.debug(f"Instance(1) not found or stale, clicking instance(0) for day {day_text}")
                    elements[0].click()
                except StaleElementReferenceException:
                    logger.debug("Stale element on instance(0), retrying find and click")
                    elements = self.driver.find_elements(AppiumBy.ANDROID_UIAUTOMATOR, selector_instance_0)
                    if elements:
                        elements[0].click()
                    else:
                        raise Exception(f"No elements found with text {day_text} for instance(0) after retry")
            else:
                raise Exception(f"No elements found with text {day_text} for instance(0) or (1)")

        def action():
            self._click_element(AppiumBy.ACCESSIBILITY_ID, "Eigenes Datum")
            for i in range(diff_months):
                self._click_element(AppiumBy.ANDROID_UIAUTOMATOR, f'new UiSelector().resourceId("undefined.header.leftArrow")')
                logger.debug(f'clicking left arrow {i+1}. time...')
            
            day_str = str(target_date.day)
            if target_date.day >= 26:
                click_day_with_instance_fallback(day_str)
            else:
                # For days < 26, just click instance(0)
                self._click_element(AppiumBy.ANDROID_UIAUTOMATOR, f'new UiSelector().text("{day_str}").instance(0)')
                logger.debug(f'clicking the day {day_str} with instance(0)')

            self._click_element(AppiumBy.ACCESSIBILITY_ID, "Ãœbernehmen")
            logger.debug("âœ… Entering the date successful.")

        self._safe_action("Selecting date...", action)


    def save_booking(self):
        def action():
            self._click_element(AppiumBy.ACCESSIBILITY_ID, "Speichern")
            logger.debug("â³ Waiting to return to main screen...")
            self._wait_for_main_screen()

        self._safe_action("Saving booking", action)

    def _wait_for_main_screen(self):
        try:
            self.wait.until(
                EC.presence_of_element_located(
                    (
                        AppiumBy.ANDROID_UIAUTOMATOR,
                        'new UiSelector().text("Buchung hinzufÃ¼gen").instance(0)',
                    )
                )
            )
            time.sleep(5)
            logger.debug("âœ… Main screen ready for next booking.")
        except TimeoutException:
            logger.warning("Warning: Main screen did not appear in time; next booking may fail.")

    def add_booking(self, amount: str, name: str, category: str, date: str = None, type: str = "give"):
        self.click_booking_button()
        self.enter_amount(amount)
        if type.lower() == "get":
            self.switch_to_positive()
        self.enter_name(name)
        self.select_category(category)
        self.select_date(date)
        self.save_booking()

    def _click_element(self, by, value):
        el = self.wait.until(EC.element_to_be_clickable((by, value)))
        el.click()

    def _send_keys(self, by, value, text):
        el = self.wait.until(EC.presence_of_element_located((by, value)))
        el.send_keys(text)

    def _safe_action(self, action_name: str, func):
        try:
            func()
            logger.debug(f"âœ… {action_name} successful")
        except Exception as e:
            screenshot_path = os.path.join(
                SCREENSHOT_DIR,
                f"{action_name.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png",
            )
            self.driver.save_screenshot(screenshot_path)
            logger.error(f"âŒ {action_name} failed! Screenshot saved: {screenshot_path}")
            raise e
---END-OF-FILE---


"config.py"
---START-OF-FILE---
# config.py

import os

# --- Appium Capabilities ---
CAPABILITIES = dict(
    platformName="Android",
    automationName="uiautomator2",
    deviceName="Android",
    appPackage="de.dwins.financeguru",
    noReset=True,
    printPageSourceOnFindFailure=True,
)

APPIUM_SERVER_URL = "http://localhost:4723"

# --- Screenshot Directory ---
SCREENSHOT_DIR = "screenshots"
os.makedirs(SCREENSHOT_DIR, exist_ok=True)
---END-OF-FILE---


"input_prompt.txt"
---START-OF-FILE---
Convert the following transaction data into the following JSON format:

```json
[
  {
    "amount": "5000",
    "name": "Groceries",
    "category": "Lebensmittel",
    "type": "give",
    "date": "2025-07-29"
  }
]
```

#### ðŸ§¾ **Instructions for Data Formatting:**

1. **Amount Formatting**

   * Multiply the decimal amount by 100 and **remove the decimal point**.
   * For example:

     * `"123.45"` âž `"12345"`
     * `"10.00"` âž `"1000"`

2. **Name Extraction**

   * Extract a **clear, human-readable label** for the `"name"` field, using these rules:

     * For **card transactions**: Use merchant name (e.g., `"Lidl"`).
     * For **bank transfers**: Use the sender name and purpose (e.g., `"UdruÅ¾enje GraÄ‘ana DIPLOCENTAR â€¢ Neoporeziva primanja"`).
   * Omit irrelevant or technical data such as:

     * Card numbers, exchange rates, internal codes, account numbers, etc.

3. **Transaction Type**

   * Use `"give"` for expenses (money out).
   * Use `"get"` for income (money in).

4. **Category Assignment**

   * Assign a `"category"` only if you are **reasonably certain**.
   * Otherwise, use default:

     * `"Sonstige Ausgaben"` for `"give"`
     * `"Sonstige Einnahmen"` for `"get"`
   * Categories must come from the following approved list (copy-paste friendly):

```
Drogerie, Elterngeld, KapitalertrÃ¤ge, Kindergeld, Leistung der Bundesagentur fÃ¼r Arbeit,
Lohn / Gehalt, Mieteinnahmen, Rente/Pension, Sonstige Einnahmen, Lebensmittel,
Lieferservice, Mittagsessen, Restaurants, Supplements, Ausleihe, BankgebÃ¼hren, FinanzApp,
Kredit, Sonstige Finanzausgaben, Spende, Steuern, BÃ¼cher & Zeitungen, Gaming,
In-App-KÃ¤ufe, Kino, Mitgliedschaft, Musik & Podcasts, Serien & Filme,
Sonstige Freizeitausgaben, Sport, Urlaub, Veranstaltungen, Apotheke,
Sonstige Gesundheitsausgaben, Ã„rztliche Behandlung, Futter & Tierbedarf,
TierÃ¤rztliche Behandlung, Kinderbetreuung, Schule & FÃ¶rderung,
Sonstige Kinderausgaben, Taschengeld, Bekleidung, Cloud-Dienste, Elektrohandel,
Friseur, Geschenke, Mobilfunk, Prime-Mitgliedschaft, Shopping,
Sonstiger Lifestyle, Auto, Bus & Bahn, Fahrrad, FlÃ¼ge, Laden,
Sharing / Gemietet, Tanken, Taxi, Bargeld, Kreditkartenabrechnung, Mama,
Sonstige Ausgaben, BTC, Bausparvertrag, Kapitalanlage, Sparen,
AnhÃ¤ngerversicherung, Bauherrenhaftpflichtversicherung, BerufsunfÃ¤higkeitsversicherung,
Betriebliche Altersvorsorge, Bootshaftpflichtversicherung, Brillenversicherung,
Drohnenhaftpflichtversicherung, GerÃ¤teversicherung, Gesetzliche Krankenversicherung,
Gesetzliche Rentenversicherung, GewÃ¤sserschadenhaftpflichtversicherung,
Haftpflichtversicherung, Hausratversicherung, Jagdhaftpflichtversicherung,
KFZ-Versicherung, Kapitallebensversicherung, Kombi-Sachversicherung,
Krankenzusatzversicherung, Lebensversicherung, Motorradversicherung,
Pflegeversicherung, Photovoltaikhaftpflichtversicherung, Private Krankenversicherung,
Rechtsschutzversicherung, Reisekrankenversicherung, Rentenversicherung,
Risikolebensversicherung, Sonstige Sachversicherung, Sonstige Versicherung,
Tierhaftpflichtversicherung, Tierkrankenversicherung, Unfallversicherung,
WohngebÃ¤udeversicherung, Wohnwagenversicherung, Zahnzusatzversicherung,
Bauen / Renovieren, Baufinanzierung, Einrichtung, Gas, Internet & Telefon,
Miete, RundfunkgebÃ¼hren, Sonstiges Wohnen, Strom
```---END-OF-FILE---


"README.md"
---START-OF-FILE---
# Finanzguru Automation Bot

Automated booking bot for the **Finanzguru** Android app using Python and Appium.  
This bot allows you to add multiple financial bookings (expenses and income) from JSON or CSV files by simulating user interactions in the app.

---

## Features

- Add bookings with amount, name, category, and optional transaction type (expense/income)  
- Supports positive (income) and negative (expense) transactions  
- Load bookings from JSON or CSV files  
- Robust error handling with screenshots on failure  
- Easy to customize and extend  
---END-OF-FILE---


"requirements.txt"
---START-OF-FILE---
Appium-Python-Client
python-dateutil
python-dotenv---END-OF-FILE---


"test_finanzguru.py"
---START-OF-FILE---
import logging
import unittest
import csv
import json
import os
import sys
import argparse  # Import the argparse module
from appium import webdriver
from appium.options.android import UiAutomator2Options
from config import CAPABILITIES, APPIUM_SERVER_URL
from bot import FinanzguruBot

args = None
logger = logging.getLogger(__name__)

def parse_arguments():
    """
    Parses command-line arguments for the test script.
    """
    parser = argparse.ArgumentParser(
        description="Run Finanzguru booking tests with data from a specified file and configurable logging."
    )
    parser.add_argument(
        "-b",
        "--booking_file",
        type=str,
        help="Path to the JSON or CSV file containing booking data.",
        required=True
    )
    parser.add_argument(
        "-l",
        "--log_level",
        type=str,
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Set the logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL). Default is INFO."
    )
    return parser.parse_args()

class TestFinanzguru(unittest.TestCase):

    def setUp(self):
        self.driver = webdriver.Remote(
            APPIUM_SERVER_URL,
            options=UiAutomator2Options().load_capabilities(CAPABILITIES),
        )
        self.bot = FinanzguruBot(self.driver)

    def tearDown(self):
        self.driver.quit()

    def _load_bookings(self, path: str):
        """Loads bookings from a given file path, supporting JSON and CSV."""
        _, file_extension = os.path.splitext(path)
        file_extension = file_extension.lower()

        with open(path, "r", encoding="utf-8") as f:
            if file_extension == ".json":
                return json.load(f)
            elif file_extension == ".csv":
                reader = csv.DictReader(f)
                return [row for row in reader]
            else:
                raise ValueError(f"Unsupported file type: {file_extension}")

    def test_add_multiple_bookings_from_file(self):  # Renamed to start with 'test_'
        """
        Tests adding multiple bookings from a file specified via command-line argument.
        """
        if not args.booking_file:
            self.fail("No booking file provided. Please use --booking_file argument.")

        booking_file = args.booking_file

        bookings = self._load_bookings(booking_file)
        total = len(bookings)
        logger.info(f"Loaded {total} bookings from {booking_file}")

        for i, booking in enumerate(bookings, start=1):
            logger.info(f"âž¡ï¸ Adding booking {i}/{total}: {booking}")
            self.bot.add_booking(**booking)

if __name__ == "__main__":
    args = parse_arguments()
    
    log_level_numeric = getattr(logging, args.log_level.upper())
    logging.basicConfig(
        level=log_level_numeric,
        format="%(asctime)s [%(levelname)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    # Clean sys.argv for unittest.main()
    sys.argv = sys.argv[:1] # Keep only the script name

    unittest.main()---END-OF-FILE---

